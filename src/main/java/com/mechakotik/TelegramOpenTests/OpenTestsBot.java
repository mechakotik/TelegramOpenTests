package com.mechakotik.TelegramOpenTests;

import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.GetFile;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.User;

import java.io.*;
import java.util.*;

public abstract class OpenTestsBot extends TelegramLongPollingBot {
    public abstract int getNumTests();

    public abstract String getStatementURL();

    public abstract String getTestsURL();

    public static class CheckResult {
        String verdict;
        double score;
    }

    public abstract CheckResult checkSolution(String path, int testNumber);

    public void onUpdateReceived(Update update) {
        try {
            handleUpdate(update);
        } catch (Exception e) {
            System.out.println("Exception thrown: " + e);
        }
    }

    private class Participant {
        String name;
        double[] scores = new double[getNumTests()];

        public double getScoreSum() {
            double sum = 0;
            for(int i = 0; i < getNumTests(); i ++) {
                sum += scores[i];
            }
            return sum;
        }
    }

    private static class StandingsElement {
        String name;
        double score;
    }

    HashMap<Long, Participant> participantMap = new HashMap<Long, Participant>();
    HashSet<String> fileIdSet = new HashSet<>();
    int lastMessageId = 0;

    public OpenTestsBot() throws Exception {
        FileReader reader = null;
        try {
            reader = new FileReader("users.txt");
        }
        catch (FileNotFoundException e) {
            return;
        }
        Scanner scanner = new Scanner(reader).useLocale(Locale.US);
        while(scanner.hasNextLong()) {
            Long id = scanner.nextLong();
            Participant participant = new Participant();
            participant.name = scanner.next();
            for(int i = 0; i < getNumTests(); i ++) {
                participant.scores[i] = scanner.nextFloat();
            }
            participantMap.put(id, participant);
        }
        reader.close();
    }

    HashSet<Long> registeringSet = new HashSet<>();

    private boolean registerParticipant(User user) throws Exception {
        if(!registeringSet.contains(user.getId()) && !participantMap.containsKey(user.getId())) {
            registeringSet.add(user.getId());
            sendText(user.getId(), "Введите ник (от 2 до 12 символов, без пробелов)");
            return true;
        }
        return false;
    }

    private boolean isCorrectName(String name) {
        if(!(2 <= name.length() && name.length() <= 12)) {
            return false;
        }
        for(char i : name.toCharArray()) {
            if(i == ' ') {
                return false;
            }
        }
        return true;
    }

    private void handleUpdate(Update update) throws Exception {
        var message = update.getMessage();
        var user = message.getFrom();
        var id = user.getId();
        if(registerParticipant(user)) {
            return;
        }
        if(registeringSet.contains(id)) {
            if(message.hasText() && isCorrectName(message.getText())) {
                Participant participant = new Participant();
                participant.name = message.getText();
                registeringSet.remove(id);
                participantMap.put(id, participant);
                sendHelp(id);
            }
            else {
                sendText(id, "Введите ник (от 2 до 12 символов, без пробелов)");
            }
        }
        else {
            lastMessageId = message.getMessageId();
            if(message.hasText()) {
                if(message.getText().equals("/help")) {
                    sendHelp(id);
                }
                else if(message.getText().equals("/standings")) {
                    sendStandings(id);
                }
                else if(message.getText().equals("/score")) {
                    sendScore(id);
                }
                else {
                    sendText(id, "Неизвестная команда");
                }
            }
            else if(message.hasDocument()) {
                var fileUniqueId = message.getDocument().getFileUniqueId();
                if(fileIdSet.contains(fileUniqueId)) {
                    sendReply(id, "Вы уже посылали этот файл");
                    return;
                }
                fileIdSet.add(fileUniqueId);
                if(message.getDocument().getFileSize() > 5e6) {
                    sendReply(id, "Размер файла не должен превышать 5 Мб");
                    return;
                }
                var fileId = message.getDocument().getFileId();
                GetFile gf = new GetFile();
                gf.setFileId(fileId);
                String filePath = execute(gf).getFilePath();
                File file = downloadFile(filePath);
                checkOutputFile(file.getPath(), message.getDocument().getFileName(), id);
            }
            else {
                sendText(id, "Неизвестная команда");
            }
        }
        saveParticipantList();
    }

    private void sendText(Long id, String text) throws Exception {
        SendMessage sm = SendMessage.builder().chatId(id.toString()).text(text).parseMode("HTML").build();
        execute(sm);
    }

    private void sendReply(Long id, String text) throws Exception {
        SendMessage sm = SendMessage.builder().chatId(id.toString()).text(text).replyToMessageId(lastMessageId).parseMode("HTML").build();
        execute(sm);
    }

    private void sendStandings(Long userId) throws Exception {
        StandingsElement[] standings = new StandingsElement[participantMap.size()]; {
            int position = 0;
            for(Map.Entry<Long, Participant> i : participantMap.entrySet()) {
                standings[position] = new StandingsElement();
                standings[position].name = i.getValue().name;
                standings[position].score = i.getValue().getScoreSum();
                position ++;
            }
        }
        Arrays.sort(standings, new Comparator<StandingsElement>() {
            @Override
            public int compare(StandingsElement o1, StandingsElement o2) {
                if(o1.score > o2.score) {
                    return -1;
                }
                if(o1.score == o2.score) {
                    return 0;
                }
                return 1;
            }
        });
        String message = "<code>";
        for(int i = 0; i < participantMap.size(); i ++) {
            message += (i + 1) + ". ";
            if(i + 1 <= 9) {
                message += " ";
            }
            message += standings[i].name;
            for(int j = 0; j < 16 - standings[i].name.length(); j ++) {
                message += " ";
            }
            message += String.format(Locale.ROOT, "%.3f", standings[i].score) + "\n";
        }
        message += "</code>";
        sendText(userId, message);
    }

    private void sendScore(Long userId) throws Exception {
        String message = "<code>";
        for(int num = 0; num < getNumTests(); num ++) {
            message += (num + 1);
            message += ": ";
            if(num + 1 <= 9) {
                message += " ";
            }
            message += String.format(Locale.ROOT, "%.3f", participantMap.get(userId).scores[num]);
            message += "\n";
        }
        message += "\nΣ:  " + String.format(Locale.ROOT, "%.3f", participantMap.get(userId).getScoreSum());
        message += "</code>";
        sendText(userId, message);
    }

    private void checkOutputFile(String path, String filename, Long userId) throws Exception {
        Integer testNumber = getNumTests();
        while(testNumber >= 1 && !filename.contains(testNumber.toString())) {
            testNumber -= 1;
        }
        if(testNumber == 0) {
            sendReply(userId, "Имя выходного файла должно содержать номер теста. Например, output1.txt");
            return;
        }
        testNumber --;

        var checkResult = checkSolution(path, testNumber);
        participantMap.get(userId).scores[testNumber] = Math.max(participantMap.get(userId).scores[testNumber], checkResult.score);
        String message = "Вердикт: " + checkResult.verdict +
                         "\nБаллы за тест: " + String.format(Locale.ROOT, "%.3f", checkResult.score);
        sendReply(userId, message);
    }

    private void sendHelp(Long id) throws Exception {
        String text = "<a href=" + '"' + getStatementURL() + '"' + ">Условие</a>\n";
        text += "<a href=" + '"' + getTestsURL() + '"' + ">Архив с тестами</a>\n";
        text += "\nСписок команд:\n";
        text += "/help - условие, список команд\n";
        text += "/score - баллы по всем тестам\n";
        text += "/standings - таблица";
        sendText(id, text);
    }

    long lastTime = 0L;

    private void saveParticipantList() throws Exception {
        Date date = new Date();
        long currentTime = date.getTime();
        if(currentTime / 300000 == lastTime / 300000) {
            return;
        }
        lastTime = currentTime;
        FileWriter writer = new FileWriter("users.txt");
        for(Map.Entry<Long, Participant> entry : participantMap.entrySet()) {
            writer.write(entry.getKey() + " ");
            writer.write(entry.getValue().name + " ");
            for(int i = 0; i < getNumTests(); i ++) {
                writer.write(entry.getValue().scores[i] + " ");
            }
            writer.write("\n");
        }
        writer.close();
    }
}
