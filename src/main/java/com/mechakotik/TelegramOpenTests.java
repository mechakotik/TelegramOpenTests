package com.mechakotik;

import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.GetFile;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Update;
import org.telegram.telegrambots.meta.api.objects.User;

import java.io.*;
import java.util.*;

public class TelegramOpenTests extends TelegramLongPollingBot {
    @Override
    public String getBotUsername() {
        return null;
    }

    @Override
    public String getBotToken() {
        return null;
    }

    @Override
    public void onUpdateReceived(Update update) {
        try {
            handleUpdate(update);
        } catch (Exception e) {
            System.out.println("Exception thrown: " + e);
        }
    }

    Checker checker = new Checker();

    private class Participant {
        String name;
        double[] scores = new double[checker.getNumTests()];

        public double getScoreSum() {
            double sum = 0;
            for(int i = 0; i < checker.getNumTests(); i ++) {
                sum += scores[i];
            }
            return sum;
        }
    }

    private class StandingsElement {
        String name;
        double score;
    }

    HashMap<Long, Participant> participantMap = new HashMap<Long, Participant>();
    HashSet<String> fileIdSet = new HashSet<>();
    int lastMessageId = 0;

    public TelegramOpenTests() throws Exception {
        FileReader reader = new FileReader("users.txt");
        Scanner scanner = new Scanner(reader).useLocale(Locale.US);
        while(scanner.hasNextLong()) {
            Long id = scanner.nextLong();
            Participant participant = new Participant();
            participant.name = scanner.next();
            for(int i = 0; i < checker.getNumTests(); i ++) {
                participant.scores[i] = scanner.nextFloat();
            }
            participantMap.put(id, participant);
        }
        reader.close();
    }

    private void registerParticipant(User user) {
        if(!participantMap.containsKey(user.getId())) {
            Participant participant = new Participant();
            participant.name = user.getUserName();
            participantMap.put(user.getId(), participant);
        }
    }

    private void handleUpdate(Update update) throws Exception {
        var message = update.getMessage();
        var user = message.getFrom();
        var id = user.getId();
        registerParticipant(user);
        lastMessageId = message.getMessageId();
        if(message.hasText()) {
            if(message.getText().equals("/start") || message.getText().equals("/statement")) {

            }
            else if(message.getText().equals("/standings")) {
                sendStandings(id);
            }
            else if(message.getText().equals("/score")) {
                sendScore(id);
            }
            else {
                sendText(id, "Неизвестная команда");
            }
        }
        else if(message.hasDocument()) {
            var fileUniqueId = message.getDocument().getFileUniqueId();
            if(fileIdSet.contains(fileUniqueId)) {
                sendReply(id, "Вы уже посылали этот файл");
                return;
            }
            fileIdSet.add(fileUniqueId);
            if(message.getDocument().getFileSize() > 5e6) {
                sendReply(id, "Размер файла не должен превышать 5 Мб");
                return;
            }
            var fileId = message.getDocument().getFileId();
            GetFile gf = new GetFile();
            gf.setFileId(fileId);
            String filePath = execute(gf).getFilePath();
            File file = downloadFile(filePath);
            checkOutputFile(file.getPath(), message.getDocument().getFileName(), id);
        }
        else {
            sendText(id, "Неизвестная команда");
        }
    }

    private void sendText(Long id, String text) throws Exception {
        SendMessage sm = SendMessage.builder().chatId(id.toString()).text(text).parseMode("HTML").build();
        execute(sm);
    }

    private void sendReply(Long id, String text) throws Exception {
        SendMessage sm = SendMessage.builder().chatId(id.toString()).text(text).replyToMessageId(lastMessageId).parseMode("HTML").build();
        execute(sm);
    }

    private void sendStandings(Long userId) throws Exception {
        StandingsElement[] standings = new StandingsElement[participantMap.size()]; {
            int position = 0;
            for(Map.Entry<Long, Participant> i : participantMap.entrySet()) {
                standings[position] = new StandingsElement();
                standings[position].name = i.getValue().name;
                standings[position].score = i.getValue().getScoreSum();
                position ++;
            }
        }
        Arrays.sort(standings, new Comparator<StandingsElement>() {
            @Override
            public int compare(StandingsElement o1, StandingsElement o2) {
                if(o1.score < o2.score) {
                    return -1;
                }
                if(o1.score == o2.score) {
                    return 0;
                }
                return 1;
            }
        });
        String message = "<code>";
        for(int i = 0; i < participantMap.size(); i ++) {
            message += (i + 1) + ". ";
            if(i + 1 <= 9) {
                message += " ";
            }
            message += standings[i].name;
            for(int j = 0; j < 16 - standings[i].name.length(); j ++) {
                message += " ";
            }
            message += String.format(Locale.ROOT, "%.3f", standings[i].score) + "\n";
        }
        message += "</code>";
        sendText(userId, message);
    }

    private void sendScore(Long userId) throws Exception {
        String message = "<code>";
        for(int num = 0; num < checker.getNumTests(); num ++) {
            message += (num + 1);
            message += ": ";
            if(num + 1 <= 9) {
                message += " ";
            }
            message += String.format(Locale.ROOT, "%.3f", participantMap.get(userId).scores[num]);
            message += "\n";
        }
        message += "\nΣ:  " + String.format(Locale.ROOT, "%.3f", participantMap.get(userId).getScoreSum());
        message += "</code>";
        sendText(userId, message);
    }

    private void checkOutputFile(String path, String filename, Long userId) throws Exception {
        Integer testNumber = checker.getNumTests();
        while(testNumber >= 1 && !filename.contains(testNumber.toString())) {
            testNumber -= 1;
        }
        if(testNumber == 0) {
            sendReply(userId, "Имя выходного файла должно содержать номер теста. Например, output1.txt");
            return;
        }
        testNumber --;

        var checkResult = checker.check(path, testNumber);
        participantMap.get(userId).scores[testNumber] = Math.max(participantMap.get(userId).scores[testNumber], checkResult.score);
        String message = "Вердикт: " + checkResult.verdict +
                         "\nБаллы за тест: " + String.format(Locale.ROOT, "%.3f", checkResult.score);
        sendReply(userId, message);
        saveParticipantList();
    }

    int saveTimer = 0;

    private void saveParticipantList() throws Exception {
        saveTimer ++;
        if(saveTimer % 10 != 0) {
            return;
        }
        FileWriter writer = new FileWriter("users.txt");
        for(Map.Entry<Long, Participant> entry : participantMap.entrySet()) {
            writer.write(entry.getKey() + " ");
            writer.write(entry.getValue().name + " ");
            for(int i = 0; i < checker.getNumTests(); i ++) {
                writer.write(entry.getValue().scores[i] + " ");
            }
            writer.write("\n");
        }
        writer.close();
    }
}
